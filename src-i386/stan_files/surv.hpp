#ifndef MODELS_HPP
#define MODELS_HPP
#define STAN__SERVICES__COMMAND_HPP
#include <rstan/rstaninc.hpp>
// Code generated by Stan version 2.17.0

#include <stan/model/model_header.hpp>

namespace model_surv_namespace {

using std::istream;
using std::string;
using std::stringstream;
using std::vector;
using stan::io::dump;
using stan::math::lgamma;
using stan::model::prob_grad;
using namespace stan::math;

typedef Eigen::Matrix<double,Eigen::Dynamic,1> vector_d;
typedef Eigen::Matrix<double,1,Eigen::Dynamic> row_vector_d;
typedef Eigen::Matrix<double,Eigen::Dynamic,Eigen::Dynamic> matrix_d;

static int current_statement_begin__;

stan::io::program_reader prog_reader__() {
    stan::io::program_reader reader;
    reader.add_event(0, 0, "start", "model_surv");
    reader.add_event(296, 296, "end", "model_surv");
    return reader;
}

int
get_nvars_for_hs(const int& prior_dist, std::ostream* pstream__) {
    typedef double fun_scalar_t__;
    typedef int fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 10;
        int hs(0);
        (void) hs;  // dummy to suppress unused var warning

        stan::math::fill(hs, std::numeric_limits<int>::min());
        stan::math::assign(hs,0);


        current_statement_begin__ = 11;
        if (as_bool(logical_eq(prior_dist,3))) {
            current_statement_begin__ = 11;
            stan::math::assign(hs, 2);
        } else if (as_bool(logical_eq(prior_dist,4))) {
            current_statement_begin__ = 12;
            stan::math::assign(hs, 4);
        }
        current_statement_begin__ = 13;
        return stan::math::promote_scalar<fun_return_scalar_t__>(hs);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct get_nvars_for_hs_functor__ {
            int
    operator()(const int& prior_dist, std::ostream* pstream__) const {
        return get_nvars_for_hs(prior_dist, pstream__);
    }
};

template <typename T0__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, typename T10__, typename T12__, typename T13__>
Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__, T7__, T8__, typename boost::math::tools::promote_args<T9__, T10__, T12__, T13__>::type>::type>::type, Eigen::Dynamic,1>
make_beta(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& z_beta,
              const int& prior_dist,
              const Eigen::Matrix<T2__, Eigen::Dynamic,1>& prior_mu,
              const Eigen::Matrix<T3__, Eigen::Dynamic,1>& prior_sd,
              const Eigen::Matrix<T4__, Eigen::Dynamic,1>& prior_df,
              const T5__& global_prior_sd,
              const std::vector<T6__>& global,
              const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic,1> >& local,
              const std::vector<T8__>& ool,
              const std::vector<Eigen::Matrix<T9__, Eigen::Dynamic,1> >& mix,
              const std::vector<T10__>& aux,
              const int& family,
              const T12__& slab_sd,
              const std::vector<T13__>& caux, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__, T7__, T8__, typename boost::math::tools::promote_args<T9__, T10__, T12__, T13__>::type>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {
        {
        current_statement_begin__ = 29;
        validate_non_negative_index("beta", "rows(z_beta)", rows(z_beta));
        Eigen::Matrix<fun_scalar_t__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(rows(z_beta)));
        (void) beta;  // dummy to suppress unused var warning

        stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
        stan::math::fill(beta,DUMMY_VAR__);


        current_statement_begin__ = 30;
        if (as_bool(logical_eq(prior_dist,0))) {
            current_statement_begin__ = 30;
            stan::math::assign(beta, z_beta);
        } else if (as_bool(logical_eq(prior_dist,1))) {
            current_statement_begin__ = 31;
            stan::math::assign(beta, add(elt_multiply(z_beta,prior_sd),prior_mu));
        }
        current_statement_begin__ = 53;
        return stan::math::promote_scalar<fun_return_scalar_t__>(beta);
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct make_beta_functor__ {
    template <typename T0__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, typename T10__, typename T12__, typename T13__>
        Eigen::Matrix<typename boost::math::tools::promote_args<T0__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__, T7__, T8__, typename boost::math::tools::promote_args<T9__, T10__, T12__, T13__>::type>::type>::type, Eigen::Dynamic,1>
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& z_beta,
              const int& prior_dist,
              const Eigen::Matrix<T2__, Eigen::Dynamic,1>& prior_mu,
              const Eigen::Matrix<T3__, Eigen::Dynamic,1>& prior_sd,
              const Eigen::Matrix<T4__, Eigen::Dynamic,1>& prior_df,
              const T5__& global_prior_sd,
              const std::vector<T6__>& global,
              const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic,1> >& local,
              const std::vector<T8__>& ool,
              const std::vector<Eigen::Matrix<T9__, Eigen::Dynamic,1> >& mix,
              const std::vector<T10__>& aux,
              const int& family,
              const T12__& slab_sd,
              const std::vector<T13__>& caux, std::ostream* pstream__) const {
        return make_beta(z_beta, prior_dist, prior_mu, prior_sd, prior_df, global_prior_sd, global, local, ool, mix, aux, family, slab_sd, caux, pstream__);
    }
};

template <typename T0__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, typename T10__, typename T_lp__, typename T_lp_accum__>
void
beta_lp(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& z_beta,
            const int& prior_dist,
            const Eigen::Matrix<T2__, Eigen::Dynamic,1>& prior_sd,
            const Eigen::Matrix<T3__, Eigen::Dynamic,1>& prior_df,
            const T4__& global_prior_df,
            const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic,1> >& local,
            const std::vector<T6__>& global,
            const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic,1> >& mix,
            const std::vector<T8__>& one_over_lambda,
            const T9__& slab_df,
            const std::vector<T10__>& caux, T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream* pstream__) {
    typedef typename boost::math::tools::promote_args<T0__, T2__, T3__, T4__, typename boost::math::tools::promote_args<T5__, T6__, T7__, T8__, typename boost::math::tools::promote_args<T9__, T10__, T_lp__>::type>::type>::type fun_scalar_t__;
    typedef fun_scalar_t__ fun_return_scalar_t__;
    const static bool propto__ = true;
    (void) propto__;
        fun_scalar_t__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

    int current_statement_begin__ = -1;
    try {

        current_statement_begin__ = 74;
        if (as_bool(logical_eq(prior_dist,1))) {
            current_statement_begin__ = 74;
            lp_accum__.add(normal_log(z_beta,0,1));
        } else if (as_bool(logical_eq(prior_dist,2))) {
            current_statement_begin__ = 75;
            lp_accum__.add(normal_log(z_beta,0,1));
        }
    } catch (const std::exception& e) {
        stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
        // Next line prevents compiler griping about no return
        throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
    }
}


struct beta_lp_functor__ {
    template <typename T0__, typename T2__, typename T3__, typename T4__, typename T5__, typename T6__, typename T7__, typename T8__, typename T9__, typename T10__, typename T_lp__, typename T_lp_accum__>
        void
    operator()(const Eigen::Matrix<T0__, Eigen::Dynamic,1>& z_beta,
            const int& prior_dist,
            const Eigen::Matrix<T2__, Eigen::Dynamic,1>& prior_sd,
            const Eigen::Matrix<T3__, Eigen::Dynamic,1>& prior_df,
            const T4__& global_prior_df,
            const std::vector<Eigen::Matrix<T5__, Eigen::Dynamic,1> >& local,
            const std::vector<T6__>& global,
            const std::vector<Eigen::Matrix<T7__, Eigen::Dynamic,1> >& mix,
            const std::vector<T8__>& one_over_lambda,
            const T9__& slab_df,
            const std::vector<T10__>& caux, T_lp__& lp__, T_lp_accum__& lp_accum__, std::ostream* pstream__) const {
        return beta_lp(z_beta, prior_dist, prior_sd, prior_df, global_prior_df, local, global, mix, one_over_lambda, slab_df, caux, lp__, lp_accum__, pstream__);
    }
};

class model_surv : public prob_grad {
private:
    int K;
    int nrows;
    int npats;
    int nevents;
    int df;
    vector<int> df_tde;
    vector_d t_beg;
    vector_d t_end;
    vector_d t_gap;
    vector_d d;
    matrix_d x;
    matrix_d fpm_x_beg;
    matrix_d fpm_x_end;
    matrix_d fpm_dx_beg;
    matrix_d fpm_dx_end;
    int dist;
    int prior_PD;
    int prior_dist;
    int prior_dist_for_exp_scale;
    int prior_dist_for_wei_shape;
    int prior_dist_for_wei_scale;
    int prior_dist_for_fpm_coefs;
    vector_d prior_mu;
    vector_d prior_sd;
    vector_d prior_df;
    double global_prior_sd;
    double global_prior_df;
    double slab_sd;
    double slab_df;
    double prior_mu_for_exp_scale;
    double prior_sd_for_exp_scale;
    double prior_df_for_exp_scale;
    double prior_mu_for_wei_shape;
    double prior_sd_for_wei_shape;
    double prior_df_for_wei_shape;
    double prior_mu_for_wei_scale;
    double prior_sd_for_wei_scale;
    double prior_df_for_wei_scale;
    vector_d prior_mu_for_fpm_coefs;
    vector_d prior_sd_for_fpm_coefs;
    vector_d prior_df_for_fpm_coefs;
    int hs;
public:
    model_surv(stan::io::var_context& context__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, 0, pstream__);
    }

    model_surv(stan::io::var_context& context__,
        unsigned int random_seed__,
        std::ostream* pstream__ = 0)
        : prob_grad(0) {
        ctor_body(context__, random_seed__, pstream__);
    }

    void ctor_body(stan::io::var_context& context__,
                   unsigned int random_seed__,
                   std::ostream* pstream__) {
        boost::ecuyer1988 base_rng__ =
          stan::services::util::create_rng(random_seed__, 0);
        (void) base_rng__;  // suppress unused var warning

        current_statement_begin__ = -1;

        static const char* function__ = "model_surv_namespace::model_surv";
        (void) function__;  // dummy to suppress unused var warning
        size_t pos__;
        (void) pos__;  // dummy to suppress unused var warning
        std::vector<int> vals_i__;
        std::vector<double> vals_r__;
        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        // initialize member variables
        try {
            current_statement_begin__ = 115;
            context__.validate_dims("data initialization", "K", "int", context__.to_vec());
            K = int(0);
            vals_i__ = context__.vals_i("K");
            pos__ = 0;
            K = vals_i__[pos__++];
            current_statement_begin__ = 116;
            context__.validate_dims("data initialization", "nrows", "int", context__.to_vec());
            nrows = int(0);
            vals_i__ = context__.vals_i("nrows");
            pos__ = 0;
            nrows = vals_i__[pos__++];
            current_statement_begin__ = 117;
            context__.validate_dims("data initialization", "npats", "int", context__.to_vec());
            npats = int(0);
            vals_i__ = context__.vals_i("npats");
            pos__ = 0;
            npats = vals_i__[pos__++];
            current_statement_begin__ = 118;
            context__.validate_dims("data initialization", "nevents", "int", context__.to_vec());
            nevents = int(0);
            vals_i__ = context__.vals_i("nevents");
            pos__ = 0;
            nevents = vals_i__[pos__++];
            current_statement_begin__ = 119;
            context__.validate_dims("data initialization", "df", "int", context__.to_vec());
            df = int(0);
            vals_i__ = context__.vals_i("df");
            pos__ = 0;
            df = vals_i__[pos__++];
            current_statement_begin__ = 120;
            validate_non_negative_index("df_tde", "K", K);
            context__.validate_dims("data initialization", "df_tde", "int", context__.to_vec(K));
            validate_non_negative_index("df_tde", "K", K);
            df_tde = std::vector<int>(K,int(0));
            vals_i__ = context__.vals_i("df_tde");
            pos__ = 0;
            size_t df_tde_limit_0__ = K;
            for (size_t i_0__ = 0; i_0__ < df_tde_limit_0__; ++i_0__) {
                df_tde[i_0__] = vals_i__[pos__++];
            }
            current_statement_begin__ = 121;
            validate_non_negative_index("t_beg", "nrows", nrows);
            context__.validate_dims("data initialization", "t_beg", "vector_d", context__.to_vec(nrows));
            validate_non_negative_index("t_beg", "nrows", nrows);
            t_beg = vector_d(static_cast<Eigen::VectorXd::Index>(nrows));
            vals_r__ = context__.vals_r("t_beg");
            pos__ = 0;
            size_t t_beg_i_vec_lim__ = nrows;
            for (size_t i_vec__ = 0; i_vec__ < t_beg_i_vec_lim__; ++i_vec__) {
                t_beg[i_vec__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 122;
            validate_non_negative_index("t_end", "nrows", nrows);
            context__.validate_dims("data initialization", "t_end", "vector_d", context__.to_vec(nrows));
            validate_non_negative_index("t_end", "nrows", nrows);
            t_end = vector_d(static_cast<Eigen::VectorXd::Index>(nrows));
            vals_r__ = context__.vals_r("t_end");
            pos__ = 0;
            size_t t_end_i_vec_lim__ = nrows;
            for (size_t i_vec__ = 0; i_vec__ < t_end_i_vec_lim__; ++i_vec__) {
                t_end[i_vec__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 123;
            validate_non_negative_index("t_gap", "nrows", nrows);
            context__.validate_dims("data initialization", "t_gap", "vector_d", context__.to_vec(nrows));
            validate_non_negative_index("t_gap", "nrows", nrows);
            t_gap = vector_d(static_cast<Eigen::VectorXd::Index>(nrows));
            vals_r__ = context__.vals_r("t_gap");
            pos__ = 0;
            size_t t_gap_i_vec_lim__ = nrows;
            for (size_t i_vec__ = 0; i_vec__ < t_gap_i_vec_lim__; ++i_vec__) {
                t_gap[i_vec__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 124;
            validate_non_negative_index("d", "nrows", nrows);
            context__.validate_dims("data initialization", "d", "vector_d", context__.to_vec(nrows));
            validate_non_negative_index("d", "nrows", nrows);
            d = vector_d(static_cast<Eigen::VectorXd::Index>(nrows));
            vals_r__ = context__.vals_r("d");
            pos__ = 0;
            size_t d_i_vec_lim__ = nrows;
            for (size_t i_vec__ = 0; i_vec__ < d_i_vec_lim__; ++i_vec__) {
                d[i_vec__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 125;
            validate_non_negative_index("x", "(logical_gt(K,0) ? nrows : 0 )", (logical_gt(K,0) ? nrows : 0 ));
            validate_non_negative_index("x", "K", K);
            context__.validate_dims("data initialization", "x", "matrix_d", context__.to_vec((logical_gt(K,0) ? nrows : 0 ),K));
            validate_non_negative_index("x", "(logical_gt(K,0) ? nrows : 0 )", (logical_gt(K,0) ? nrows : 0 ));
            validate_non_negative_index("x", "K", K);
            x = matrix_d(static_cast<Eigen::VectorXd::Index>((logical_gt(K,0) ? nrows : 0 )),static_cast<Eigen::VectorXd::Index>(K));
            vals_r__ = context__.vals_r("x");
            pos__ = 0;
            size_t x_m_mat_lim__ = (logical_gt(K,0) ? nrows : 0 );
            size_t x_n_mat_lim__ = K;
            for (size_t n_mat__ = 0; n_mat__ < x_n_mat_lim__; ++n_mat__) {
                for (size_t m_mat__ = 0; m_mat__ < x_m_mat_lim__; ++m_mat__) {
                    x(m_mat__,n_mat__) = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 126;
            validate_non_negative_index("fpm_x_beg", "nrows", nrows);
            validate_non_negative_index("fpm_x_beg", "df", df);
            context__.validate_dims("data initialization", "fpm_x_beg", "matrix_d", context__.to_vec(nrows,df));
            validate_non_negative_index("fpm_x_beg", "nrows", nrows);
            validate_non_negative_index("fpm_x_beg", "df", df);
            fpm_x_beg = matrix_d(static_cast<Eigen::VectorXd::Index>(nrows),static_cast<Eigen::VectorXd::Index>(df));
            vals_r__ = context__.vals_r("fpm_x_beg");
            pos__ = 0;
            size_t fpm_x_beg_m_mat_lim__ = nrows;
            size_t fpm_x_beg_n_mat_lim__ = df;
            for (size_t n_mat__ = 0; n_mat__ < fpm_x_beg_n_mat_lim__; ++n_mat__) {
                for (size_t m_mat__ = 0; m_mat__ < fpm_x_beg_m_mat_lim__; ++m_mat__) {
                    fpm_x_beg(m_mat__,n_mat__) = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 127;
            validate_non_negative_index("fpm_x_end", "nrows", nrows);
            validate_non_negative_index("fpm_x_end", "df", df);
            context__.validate_dims("data initialization", "fpm_x_end", "matrix_d", context__.to_vec(nrows,df));
            validate_non_negative_index("fpm_x_end", "nrows", nrows);
            validate_non_negative_index("fpm_x_end", "df", df);
            fpm_x_end = matrix_d(static_cast<Eigen::VectorXd::Index>(nrows),static_cast<Eigen::VectorXd::Index>(df));
            vals_r__ = context__.vals_r("fpm_x_end");
            pos__ = 0;
            size_t fpm_x_end_m_mat_lim__ = nrows;
            size_t fpm_x_end_n_mat_lim__ = df;
            for (size_t n_mat__ = 0; n_mat__ < fpm_x_end_n_mat_lim__; ++n_mat__) {
                for (size_t m_mat__ = 0; m_mat__ < fpm_x_end_m_mat_lim__; ++m_mat__) {
                    fpm_x_end(m_mat__,n_mat__) = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 128;
            validate_non_negative_index("fpm_dx_beg", "nrows", nrows);
            validate_non_negative_index("fpm_dx_beg", "df", df);
            context__.validate_dims("data initialization", "fpm_dx_beg", "matrix_d", context__.to_vec(nrows,df));
            validate_non_negative_index("fpm_dx_beg", "nrows", nrows);
            validate_non_negative_index("fpm_dx_beg", "df", df);
            fpm_dx_beg = matrix_d(static_cast<Eigen::VectorXd::Index>(nrows),static_cast<Eigen::VectorXd::Index>(df));
            vals_r__ = context__.vals_r("fpm_dx_beg");
            pos__ = 0;
            size_t fpm_dx_beg_m_mat_lim__ = nrows;
            size_t fpm_dx_beg_n_mat_lim__ = df;
            for (size_t n_mat__ = 0; n_mat__ < fpm_dx_beg_n_mat_lim__; ++n_mat__) {
                for (size_t m_mat__ = 0; m_mat__ < fpm_dx_beg_m_mat_lim__; ++m_mat__) {
                    fpm_dx_beg(m_mat__,n_mat__) = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 129;
            validate_non_negative_index("fpm_dx_end", "nrows", nrows);
            validate_non_negative_index("fpm_dx_end", "df", df);
            context__.validate_dims("data initialization", "fpm_dx_end", "matrix_d", context__.to_vec(nrows,df));
            validate_non_negative_index("fpm_dx_end", "nrows", nrows);
            validate_non_negative_index("fpm_dx_end", "df", df);
            fpm_dx_end = matrix_d(static_cast<Eigen::VectorXd::Index>(nrows),static_cast<Eigen::VectorXd::Index>(df));
            vals_r__ = context__.vals_r("fpm_dx_end");
            pos__ = 0;
            size_t fpm_dx_end_m_mat_lim__ = nrows;
            size_t fpm_dx_end_n_mat_lim__ = df;
            for (size_t n_mat__ = 0; n_mat__ < fpm_dx_end_n_mat_lim__; ++n_mat__) {
                for (size_t m_mat__ = 0; m_mat__ < fpm_dx_end_m_mat_lim__; ++m_mat__) {
                    fpm_dx_end(m_mat__,n_mat__) = vals_r__[pos__++];
                }
            }
            current_statement_begin__ = 135;
            context__.validate_dims("data initialization", "dist", "int", context__.to_vec());
            dist = int(0);
            vals_i__ = context__.vals_i("dist");
            pos__ = 0;
            dist = vals_i__[pos__++];
            current_statement_begin__ = 138;
            context__.validate_dims("data initialization", "prior_PD", "int", context__.to_vec());
            prior_PD = int(0);
            vals_i__ = context__.vals_i("prior_PD");
            pos__ = 0;
            prior_PD = vals_i__[pos__++];
            current_statement_begin__ = 148;
            context__.validate_dims("data initialization", "prior_dist", "int", context__.to_vec());
            prior_dist = int(0);
            vals_i__ = context__.vals_i("prior_dist");
            pos__ = 0;
            prior_dist = vals_i__[pos__++];
            current_statement_begin__ = 155;
            context__.validate_dims("data initialization", "prior_dist_for_exp_scale", "int", context__.to_vec());
            prior_dist_for_exp_scale = int(0);
            vals_i__ = context__.vals_i("prior_dist_for_exp_scale");
            pos__ = 0;
            prior_dist_for_exp_scale = vals_i__[pos__++];
            current_statement_begin__ = 156;
            context__.validate_dims("data initialization", "prior_dist_for_wei_shape", "int", context__.to_vec());
            prior_dist_for_wei_shape = int(0);
            vals_i__ = context__.vals_i("prior_dist_for_wei_shape");
            pos__ = 0;
            prior_dist_for_wei_shape = vals_i__[pos__++];
            current_statement_begin__ = 157;
            context__.validate_dims("data initialization", "prior_dist_for_wei_scale", "int", context__.to_vec());
            prior_dist_for_wei_scale = int(0);
            vals_i__ = context__.vals_i("prior_dist_for_wei_scale");
            pos__ = 0;
            prior_dist_for_wei_scale = vals_i__[pos__++];
            current_statement_begin__ = 163;
            context__.validate_dims("data initialization", "prior_dist_for_fpm_coefs", "int", context__.to_vec());
            prior_dist_for_fpm_coefs = int(0);
            vals_i__ = context__.vals_i("prior_dist_for_fpm_coefs");
            pos__ = 0;
            prior_dist_for_fpm_coefs = vals_i__[pos__++];
            current_statement_begin__ = 166;
            validate_non_negative_index("prior_mu", "K", K);
            context__.validate_dims("data initialization", "prior_mu", "vector_d", context__.to_vec(K));
            validate_non_negative_index("prior_mu", "K", K);
            prior_mu = vector_d(static_cast<Eigen::VectorXd::Index>(K));
            vals_r__ = context__.vals_r("prior_mu");
            pos__ = 0;
            size_t prior_mu_i_vec_lim__ = K;
            for (size_t i_vec__ = 0; i_vec__ < prior_mu_i_vec_lim__; ++i_vec__) {
                prior_mu[i_vec__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 167;
            validate_non_negative_index("prior_sd", "K", K);
            context__.validate_dims("data initialization", "prior_sd", "vector_d", context__.to_vec(K));
            validate_non_negative_index("prior_sd", "K", K);
            prior_sd = vector_d(static_cast<Eigen::VectorXd::Index>(K));
            vals_r__ = context__.vals_r("prior_sd");
            pos__ = 0;
            size_t prior_sd_i_vec_lim__ = K;
            for (size_t i_vec__ = 0; i_vec__ < prior_sd_i_vec_lim__; ++i_vec__) {
                prior_sd[i_vec__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 168;
            validate_non_negative_index("prior_df", "K", K);
            context__.validate_dims("data initialization", "prior_df", "vector_d", context__.to_vec(K));
            validate_non_negative_index("prior_df", "K", K);
            prior_df = vector_d(static_cast<Eigen::VectorXd::Index>(K));
            vals_r__ = context__.vals_r("prior_df");
            pos__ = 0;
            size_t prior_df_i_vec_lim__ = K;
            for (size_t i_vec__ = 0; i_vec__ < prior_df_i_vec_lim__; ++i_vec__) {
                prior_df[i_vec__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 169;
            context__.validate_dims("data initialization", "global_prior_sd", "double", context__.to_vec());
            global_prior_sd = double(0);
            vals_r__ = context__.vals_r("global_prior_sd");
            pos__ = 0;
            global_prior_sd = vals_r__[pos__++];
            current_statement_begin__ = 170;
            context__.validate_dims("data initialization", "global_prior_df", "double", context__.to_vec());
            global_prior_df = double(0);
            vals_r__ = context__.vals_r("global_prior_df");
            pos__ = 0;
            global_prior_df = vals_r__[pos__++];
            current_statement_begin__ = 171;
            context__.validate_dims("data initialization", "slab_sd", "double", context__.to_vec());
            slab_sd = double(0);
            vals_r__ = context__.vals_r("slab_sd");
            pos__ = 0;
            slab_sd = vals_r__[pos__++];
            current_statement_begin__ = 172;
            context__.validate_dims("data initialization", "slab_df", "double", context__.to_vec());
            slab_df = double(0);
            vals_r__ = context__.vals_r("slab_df");
            pos__ = 0;
            slab_df = vals_r__[pos__++];
            current_statement_begin__ = 175;
            context__.validate_dims("data initialization", "prior_mu_for_exp_scale", "double", context__.to_vec());
            prior_mu_for_exp_scale = double(0);
            vals_r__ = context__.vals_r("prior_mu_for_exp_scale");
            pos__ = 0;
            prior_mu_for_exp_scale = vals_r__[pos__++];
            current_statement_begin__ = 176;
            context__.validate_dims("data initialization", "prior_sd_for_exp_scale", "double", context__.to_vec());
            prior_sd_for_exp_scale = double(0);
            vals_r__ = context__.vals_r("prior_sd_for_exp_scale");
            pos__ = 0;
            prior_sd_for_exp_scale = vals_r__[pos__++];
            current_statement_begin__ = 177;
            context__.validate_dims("data initialization", "prior_df_for_exp_scale", "double", context__.to_vec());
            prior_df_for_exp_scale = double(0);
            vals_r__ = context__.vals_r("prior_df_for_exp_scale");
            pos__ = 0;
            prior_df_for_exp_scale = vals_r__[pos__++];
            current_statement_begin__ = 178;
            context__.validate_dims("data initialization", "prior_mu_for_wei_shape", "double", context__.to_vec());
            prior_mu_for_wei_shape = double(0);
            vals_r__ = context__.vals_r("prior_mu_for_wei_shape");
            pos__ = 0;
            prior_mu_for_wei_shape = vals_r__[pos__++];
            current_statement_begin__ = 179;
            context__.validate_dims("data initialization", "prior_sd_for_wei_shape", "double", context__.to_vec());
            prior_sd_for_wei_shape = double(0);
            vals_r__ = context__.vals_r("prior_sd_for_wei_shape");
            pos__ = 0;
            prior_sd_for_wei_shape = vals_r__[pos__++];
            current_statement_begin__ = 180;
            context__.validate_dims("data initialization", "prior_df_for_wei_shape", "double", context__.to_vec());
            prior_df_for_wei_shape = double(0);
            vals_r__ = context__.vals_r("prior_df_for_wei_shape");
            pos__ = 0;
            prior_df_for_wei_shape = vals_r__[pos__++];
            current_statement_begin__ = 181;
            context__.validate_dims("data initialization", "prior_mu_for_wei_scale", "double", context__.to_vec());
            prior_mu_for_wei_scale = double(0);
            vals_r__ = context__.vals_r("prior_mu_for_wei_scale");
            pos__ = 0;
            prior_mu_for_wei_scale = vals_r__[pos__++];
            current_statement_begin__ = 182;
            context__.validate_dims("data initialization", "prior_sd_for_wei_scale", "double", context__.to_vec());
            prior_sd_for_wei_scale = double(0);
            vals_r__ = context__.vals_r("prior_sd_for_wei_scale");
            pos__ = 0;
            prior_sd_for_wei_scale = vals_r__[pos__++];
            current_statement_begin__ = 183;
            context__.validate_dims("data initialization", "prior_df_for_wei_scale", "double", context__.to_vec());
            prior_df_for_wei_scale = double(0);
            vals_r__ = context__.vals_r("prior_df_for_wei_scale");
            pos__ = 0;
            prior_df_for_wei_scale = vals_r__[pos__++];
            current_statement_begin__ = 184;
            validate_non_negative_index("prior_mu_for_fpm_coefs", "df", df);
            context__.validate_dims("data initialization", "prior_mu_for_fpm_coefs", "vector_d", context__.to_vec(df));
            validate_non_negative_index("prior_mu_for_fpm_coefs", "df", df);
            prior_mu_for_fpm_coefs = vector_d(static_cast<Eigen::VectorXd::Index>(df));
            vals_r__ = context__.vals_r("prior_mu_for_fpm_coefs");
            pos__ = 0;
            size_t prior_mu_for_fpm_coefs_i_vec_lim__ = df;
            for (size_t i_vec__ = 0; i_vec__ < prior_mu_for_fpm_coefs_i_vec_lim__; ++i_vec__) {
                prior_mu_for_fpm_coefs[i_vec__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 185;
            validate_non_negative_index("prior_sd_for_fpm_coefs", "df", df);
            context__.validate_dims("data initialization", "prior_sd_for_fpm_coefs", "vector_d", context__.to_vec(df));
            validate_non_negative_index("prior_sd_for_fpm_coefs", "df", df);
            prior_sd_for_fpm_coefs = vector_d(static_cast<Eigen::VectorXd::Index>(df));
            vals_r__ = context__.vals_r("prior_sd_for_fpm_coefs");
            pos__ = 0;
            size_t prior_sd_for_fpm_coefs_i_vec_lim__ = df;
            for (size_t i_vec__ = 0; i_vec__ < prior_sd_for_fpm_coefs_i_vec_lim__; ++i_vec__) {
                prior_sd_for_fpm_coefs[i_vec__] = vals_r__[pos__++];
            }
            current_statement_begin__ = 186;
            validate_non_negative_index("prior_df_for_fpm_coefs", "df", df);
            context__.validate_dims("data initialization", "prior_df_for_fpm_coefs", "vector_d", context__.to_vec(df));
            validate_non_negative_index("prior_df_for_fpm_coefs", "df", df);
            prior_df_for_fpm_coefs = vector_d(static_cast<Eigen::VectorXd::Index>(df));
            vals_r__ = context__.vals_r("prior_df_for_fpm_coefs");
            pos__ = 0;
            size_t prior_df_for_fpm_coefs_i_vec_lim__ = df;
            for (size_t i_vec__ = 0; i_vec__ < prior_df_for_fpm_coefs_i_vec_lim__; ++i_vec__) {
                prior_df_for_fpm_coefs[i_vec__] = vals_r__[pos__++];
            }

            // validate, data variables
            current_statement_begin__ = 115;
            check_greater_or_equal(function__,"K",K,0);
            current_statement_begin__ = 116;
            check_greater_or_equal(function__,"nrows",nrows,0);
            current_statement_begin__ = 117;
            check_greater_or_equal(function__,"npats",npats,0);
            current_statement_begin__ = 118;
            check_greater_or_equal(function__,"nevents",nevents,0);
            current_statement_begin__ = 119;
            check_greater_or_equal(function__,"df",df,0);
            current_statement_begin__ = 120;
            for (int k0__ = 0; k0__ < K; ++k0__) {
                check_greater_or_equal(function__,"df_tde[k0__]",df_tde[k0__],0);
            }
            current_statement_begin__ = 121;
            current_statement_begin__ = 122;
            current_statement_begin__ = 123;
            current_statement_begin__ = 124;
            current_statement_begin__ = 125;
            current_statement_begin__ = 126;
            current_statement_begin__ = 127;
            current_statement_begin__ = 128;
            current_statement_begin__ = 129;
            current_statement_begin__ = 135;
            check_greater_or_equal(function__,"dist",dist,1);
            check_less_or_equal(function__,"dist",dist,3);
            current_statement_begin__ = 138;
            check_greater_or_equal(function__,"prior_PD",prior_PD,0);
            check_less_or_equal(function__,"prior_PD",prior_PD,1);
            current_statement_begin__ = 148;
            check_greater_or_equal(function__,"prior_dist",prior_dist,0);
            check_less_or_equal(function__,"prior_dist",prior_dist,6);
            current_statement_begin__ = 155;
            check_greater_or_equal(function__,"prior_dist_for_exp_scale",prior_dist_for_exp_scale,0);
            check_less_or_equal(function__,"prior_dist_for_exp_scale",prior_dist_for_exp_scale,3);
            current_statement_begin__ = 156;
            check_greater_or_equal(function__,"prior_dist_for_wei_shape",prior_dist_for_wei_shape,0);
            check_less_or_equal(function__,"prior_dist_for_wei_shape",prior_dist_for_wei_shape,3);
            current_statement_begin__ = 157;
            check_greater_or_equal(function__,"prior_dist_for_wei_scale",prior_dist_for_wei_scale,0);
            check_less_or_equal(function__,"prior_dist_for_wei_scale",prior_dist_for_wei_scale,3);
            current_statement_begin__ = 163;
            check_greater_or_equal(function__,"prior_dist_for_fpm_coefs",prior_dist_for_fpm_coefs,0);
            check_less_or_equal(function__,"prior_dist_for_fpm_coefs",prior_dist_for_fpm_coefs,2);
            current_statement_begin__ = 166;
            current_statement_begin__ = 167;
            check_greater_or_equal(function__,"prior_sd",prior_sd,0);
            current_statement_begin__ = 168;
            check_greater_or_equal(function__,"prior_df",prior_df,0);
            current_statement_begin__ = 169;
            check_greater_or_equal(function__,"global_prior_sd",global_prior_sd,0);
            current_statement_begin__ = 170;
            check_greater_or_equal(function__,"global_prior_df",global_prior_df,0);
            current_statement_begin__ = 171;
            check_greater_or_equal(function__,"slab_sd",slab_sd,0);
            current_statement_begin__ = 172;
            check_greater_or_equal(function__,"slab_df",slab_df,0);
            current_statement_begin__ = 175;
            current_statement_begin__ = 176;
            check_greater_or_equal(function__,"prior_sd_for_exp_scale",prior_sd_for_exp_scale,0);
            current_statement_begin__ = 177;
            check_greater_or_equal(function__,"prior_df_for_exp_scale",prior_df_for_exp_scale,0);
            current_statement_begin__ = 178;
            current_statement_begin__ = 179;
            check_greater_or_equal(function__,"prior_sd_for_wei_shape",prior_sd_for_wei_shape,0);
            current_statement_begin__ = 180;
            check_greater_or_equal(function__,"prior_df_for_wei_shape",prior_df_for_wei_shape,0);
            current_statement_begin__ = 181;
            current_statement_begin__ = 182;
            check_greater_or_equal(function__,"prior_sd_for_wei_scale",prior_sd_for_wei_scale,0);
            current_statement_begin__ = 183;
            check_greater_or_equal(function__,"prior_df_for_wei_scale",prior_df_for_wei_scale,0);
            current_statement_begin__ = 184;
            current_statement_begin__ = 185;
            check_greater_or_equal(function__,"prior_sd_for_fpm_coefs",prior_sd_for_fpm_coefs,0);
            current_statement_begin__ = 186;
            check_greater_or_equal(function__,"prior_df_for_fpm_coefs",prior_df_for_fpm_coefs,0);
            // initialize data variables
            current_statement_begin__ = 190;
            hs = int(0);
            stan::math::fill(hs, std::numeric_limits<int>::min());
            stan::math::assign(hs,get_nvars_for_hs(prior_dist, pstream__));


            // validate transformed data
            current_statement_begin__ = 190;
            check_greater_or_equal(function__,"hs",hs,0);

            // validate, set parameter ranges
            num_params_r__ = 0U;
            param_ranges_i__.clear();
            current_statement_begin__ = 196;
            validate_non_negative_index("z_beta", "K", K);
            num_params_r__ += K;
            current_statement_begin__ = 199;
            validate_non_negative_index("z_exp_scale", "logical_eq(dist,1)", logical_eq(dist,1));
            num_params_r__ += logical_eq(dist,1);
            current_statement_begin__ = 200;
            validate_non_negative_index("z_wei_shape", "logical_eq(dist,2)", logical_eq(dist,2));
            num_params_r__ += logical_eq(dist,2);
            current_statement_begin__ = 201;
            validate_non_negative_index("z_wei_scale", "logical_eq(dist,2)", logical_eq(dist,2));
            num_params_r__ += logical_eq(dist,2);
            current_statement_begin__ = 202;
            validate_non_negative_index("z_fpm_coefs", "df", df);
            validate_non_negative_index("z_fpm_coefs", "logical_eq(dist,3)", logical_eq(dist,3));
            num_params_r__ += df * logical_eq(dist,3);
            current_statement_begin__ = 205;
            validate_non_negative_index("global", "hs", hs);
            num_params_r__ += hs;
            current_statement_begin__ = 206;
            validate_non_negative_index("local", "(logical_gt(hs,0) ? K : 0 )", (logical_gt(hs,0) ? K : 0 ));
            validate_non_negative_index("local", "hs", hs);
            num_params_r__ += (logical_gt(hs,0) ? K : 0 ) * hs;
            current_statement_begin__ = 207;
            validate_non_negative_index("caux", "logical_gt(hs,0)", logical_gt(hs,0));
            num_params_r__ += logical_gt(hs,0);
            current_statement_begin__ = 208;
            validate_non_negative_index("mix", "K", K);
            validate_non_negative_index("mix", "(primitive_value(logical_eq(prior_dist,5)) || primitive_value(logical_eq(prior_dist,6)))", (primitive_value(logical_eq(prior_dist,5)) || primitive_value(logical_eq(prior_dist,6))));
            num_params_r__ += K * (primitive_value(logical_eq(prior_dist,5)) || primitive_value(logical_eq(prior_dist,6)));
            current_statement_begin__ = 209;
            validate_non_negative_index("ool", "logical_eq(prior_dist,6)", logical_eq(prior_dist,6));
            num_params_r__ += logical_eq(prior_dist,6);
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    ~model_surv() { }


    void transform_inits(const stan::io::var_context& context__,
                         std::vector<int>& params_i__,
                         std::vector<double>& params_r__,
                         std::ostream* pstream__) const {
        stan::io::writer<double> writer__(params_r__,params_i__);
        size_t pos__;
        (void) pos__; // dummy call to supress warning
        std::vector<double> vals_r__;
        std::vector<int> vals_i__;

        if (!(context__.contains_r("z_beta")))
            throw std::runtime_error("variable z_beta missing");
        vals_r__ = context__.vals_r("z_beta");
        pos__ = 0U;
        validate_non_negative_index("z_beta", "K", K);
        context__.validate_dims("initialization", "z_beta", "vector_d", context__.to_vec(K));
        vector_d z_beta(static_cast<Eigen::VectorXd::Index>(K));
        for (int j1__ = 0U; j1__ < K; ++j1__)
            z_beta(j1__) = vals_r__[pos__++];
        try {
            writer__.vector_unconstrain(z_beta);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable z_beta: ") + e.what());
        }

        if (!(context__.contains_r("z_exp_scale")))
            throw std::runtime_error("variable z_exp_scale missing");
        vals_r__ = context__.vals_r("z_exp_scale");
        pos__ = 0U;
        validate_non_negative_index("z_exp_scale", "logical_eq(dist,1)", logical_eq(dist,1));
        context__.validate_dims("initialization", "z_exp_scale", "double", context__.to_vec(logical_eq(dist,1)));
        std::vector<double> z_exp_scale(logical_eq(dist,1),double(0));
        for (int i0__ = 0U; i0__ < logical_eq(dist,1); ++i0__)
            z_exp_scale[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < logical_eq(dist,1); ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,z_exp_scale[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable z_exp_scale: ") + e.what());
        }

        if (!(context__.contains_r("z_wei_shape")))
            throw std::runtime_error("variable z_wei_shape missing");
        vals_r__ = context__.vals_r("z_wei_shape");
        pos__ = 0U;
        validate_non_negative_index("z_wei_shape", "logical_eq(dist,2)", logical_eq(dist,2));
        context__.validate_dims("initialization", "z_wei_shape", "double", context__.to_vec(logical_eq(dist,2)));
        std::vector<double> z_wei_shape(logical_eq(dist,2),double(0));
        for (int i0__ = 0U; i0__ < logical_eq(dist,2); ++i0__)
            z_wei_shape[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < logical_eq(dist,2); ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,z_wei_shape[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable z_wei_shape: ") + e.what());
        }

        if (!(context__.contains_r("z_wei_scale")))
            throw std::runtime_error("variable z_wei_scale missing");
        vals_r__ = context__.vals_r("z_wei_scale");
        pos__ = 0U;
        validate_non_negative_index("z_wei_scale", "logical_eq(dist,2)", logical_eq(dist,2));
        context__.validate_dims("initialization", "z_wei_scale", "double", context__.to_vec(logical_eq(dist,2)));
        std::vector<double> z_wei_scale(logical_eq(dist,2),double(0));
        for (int i0__ = 0U; i0__ < logical_eq(dist,2); ++i0__)
            z_wei_scale[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < logical_eq(dist,2); ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,z_wei_scale[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable z_wei_scale: ") + e.what());
        }

        if (!(context__.contains_r("z_fpm_coefs")))
            throw std::runtime_error("variable z_fpm_coefs missing");
        vals_r__ = context__.vals_r("z_fpm_coefs");
        pos__ = 0U;
        validate_non_negative_index("z_fpm_coefs", "logical_eq(dist,3)", logical_eq(dist,3));
        validate_non_negative_index("z_fpm_coefs", "df", df);
        context__.validate_dims("initialization", "z_fpm_coefs", "vector_d", context__.to_vec(logical_eq(dist,3),df));
        std::vector<vector_d> z_fpm_coefs(logical_eq(dist,3),vector_d(static_cast<Eigen::VectorXd::Index>(df)));
        for (int j1__ = 0U; j1__ < df; ++j1__)
            for (int i0__ = 0U; i0__ < logical_eq(dist,3); ++i0__)
                z_fpm_coefs[i0__](j1__) = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < logical_eq(dist,3); ++i0__)
            try {
            writer__.vector_unconstrain(z_fpm_coefs[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable z_fpm_coefs: ") + e.what());
        }

        if (!(context__.contains_r("global")))
            throw std::runtime_error("variable global missing");
        vals_r__ = context__.vals_r("global");
        pos__ = 0U;
        validate_non_negative_index("global", "hs", hs);
        context__.validate_dims("initialization", "global", "double", context__.to_vec(hs));
        std::vector<double> global(hs,double(0));
        for (int i0__ = 0U; i0__ < hs; ++i0__)
            global[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < hs; ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,global[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable global: ") + e.what());
        }

        if (!(context__.contains_r("local")))
            throw std::runtime_error("variable local missing");
        vals_r__ = context__.vals_r("local");
        pos__ = 0U;
        validate_non_negative_index("local", "hs", hs);
        validate_non_negative_index("local", "(logical_gt(hs,0) ? K : 0 )", (logical_gt(hs,0) ? K : 0 ));
        context__.validate_dims("initialization", "local", "vector_d", context__.to_vec(hs,(logical_gt(hs,0) ? K : 0 )));
        std::vector<vector_d> local(hs,vector_d(static_cast<Eigen::VectorXd::Index>((logical_gt(hs,0) ? K : 0 ))));
        for (int j1__ = 0U; j1__ < (logical_gt(hs,0) ? K : 0 ); ++j1__)
            for (int i0__ = 0U; i0__ < hs; ++i0__)
                local[i0__](j1__) = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < hs; ++i0__)
            try {
            writer__.vector_lb_unconstrain(0,local[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable local: ") + e.what());
        }

        if (!(context__.contains_r("caux")))
            throw std::runtime_error("variable caux missing");
        vals_r__ = context__.vals_r("caux");
        pos__ = 0U;
        validate_non_negative_index("caux", "logical_gt(hs,0)", logical_gt(hs,0));
        context__.validate_dims("initialization", "caux", "double", context__.to_vec(logical_gt(hs,0)));
        std::vector<double> caux(logical_gt(hs,0),double(0));
        for (int i0__ = 0U; i0__ < logical_gt(hs,0); ++i0__)
            caux[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < logical_gt(hs,0); ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,caux[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable caux: ") + e.what());
        }

        if (!(context__.contains_r("mix")))
            throw std::runtime_error("variable mix missing");
        vals_r__ = context__.vals_r("mix");
        pos__ = 0U;
        validate_non_negative_index("mix", "(primitive_value(logical_eq(prior_dist,5)) || primitive_value(logical_eq(prior_dist,6)))", (primitive_value(logical_eq(prior_dist,5)) || primitive_value(logical_eq(prior_dist,6))));
        validate_non_negative_index("mix", "K", K);
        context__.validate_dims("initialization", "mix", "vector_d", context__.to_vec((primitive_value(logical_eq(prior_dist,5)) || primitive_value(logical_eq(prior_dist,6))),K));
        std::vector<vector_d> mix((primitive_value(logical_eq(prior_dist,5)) || primitive_value(logical_eq(prior_dist,6))),vector_d(static_cast<Eigen::VectorXd::Index>(K)));
        for (int j1__ = 0U; j1__ < K; ++j1__)
            for (int i0__ = 0U; i0__ < (primitive_value(logical_eq(prior_dist,5)) || primitive_value(logical_eq(prior_dist,6))); ++i0__)
                mix[i0__](j1__) = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < (primitive_value(logical_eq(prior_dist,5)) || primitive_value(logical_eq(prior_dist,6))); ++i0__)
            try {
            writer__.vector_lb_unconstrain(0,mix[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable mix: ") + e.what());
        }

        if (!(context__.contains_r("ool")))
            throw std::runtime_error("variable ool missing");
        vals_r__ = context__.vals_r("ool");
        pos__ = 0U;
        validate_non_negative_index("ool", "logical_eq(prior_dist,6)", logical_eq(prior_dist,6));
        context__.validate_dims("initialization", "ool", "double", context__.to_vec(logical_eq(prior_dist,6)));
        std::vector<double> ool(logical_eq(prior_dist,6),double(0));
        for (int i0__ = 0U; i0__ < logical_eq(prior_dist,6); ++i0__)
            ool[i0__] = vals_r__[pos__++];
        for (int i0__ = 0U; i0__ < logical_eq(prior_dist,6); ++i0__)
            try {
            writer__.scalar_lb_unconstrain(0,ool[i0__]);
        } catch (const std::exception& e) { 
            throw std::runtime_error(std::string("Error transforming variable ool: ") + e.what());
        }

        params_r__ = writer__.data_r();
        params_i__ = writer__.data_i();
    }

    void transform_inits(const stan::io::var_context& context,
                         Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                         std::ostream* pstream__) const {
      std::vector<double> params_r_vec;
      std::vector<int> params_i_vec;
      transform_inits(context, params_i_vec, params_r_vec, pstream__);
      params_r.resize(params_r_vec.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r(i) = params_r_vec[i];
    }


    template <bool propto__, bool jacobian__, typename T__>
    T__ log_prob(vector<T__>& params_r__,
                 vector<int>& params_i__,
                 std::ostream* pstream__ = 0) const {

        T__ DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        T__ lp__(0.0);
        stan::math::accumulator<T__> lp_accum__;

        try {
            // model parameters
            stan::io::reader<T__> in__(params_r__,params_i__);

            Eigen::Matrix<T__,Eigen::Dynamic,1>  z_beta;
            (void) z_beta;  // dummy to suppress unused var warning
            if (jacobian__)
                z_beta = in__.vector_constrain(K,lp__);
            else
                z_beta = in__.vector_constrain(K);

            vector<T__> z_exp_scale;
            size_t dim_z_exp_scale_0__ = logical_eq(dist,1);
            z_exp_scale.reserve(dim_z_exp_scale_0__);
            for (size_t k_0__ = 0; k_0__ < dim_z_exp_scale_0__; ++k_0__) {
                if (jacobian__)
                    z_exp_scale.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    z_exp_scale.push_back(in__.scalar_lb_constrain(0));
            }

            vector<T__> z_wei_shape;
            size_t dim_z_wei_shape_0__ = logical_eq(dist,2);
            z_wei_shape.reserve(dim_z_wei_shape_0__);
            for (size_t k_0__ = 0; k_0__ < dim_z_wei_shape_0__; ++k_0__) {
                if (jacobian__)
                    z_wei_shape.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    z_wei_shape.push_back(in__.scalar_lb_constrain(0));
            }

            vector<T__> z_wei_scale;
            size_t dim_z_wei_scale_0__ = logical_eq(dist,2);
            z_wei_scale.reserve(dim_z_wei_scale_0__);
            for (size_t k_0__ = 0; k_0__ < dim_z_wei_scale_0__; ++k_0__) {
                if (jacobian__)
                    z_wei_scale.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    z_wei_scale.push_back(in__.scalar_lb_constrain(0));
            }

            vector<Eigen::Matrix<T__,Eigen::Dynamic,1> > z_fpm_coefs;
            size_t dim_z_fpm_coefs_0__ = logical_eq(dist,3);
            z_fpm_coefs.reserve(dim_z_fpm_coefs_0__);
            for (size_t k_0__ = 0; k_0__ < dim_z_fpm_coefs_0__; ++k_0__) {
                if (jacobian__)
                    z_fpm_coefs.push_back(in__.vector_constrain(df,lp__));
                else
                    z_fpm_coefs.push_back(in__.vector_constrain(df));
            }

            vector<T__> global;
            size_t dim_global_0__ = hs;
            global.reserve(dim_global_0__);
            for (size_t k_0__ = 0; k_0__ < dim_global_0__; ++k_0__) {
                if (jacobian__)
                    global.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    global.push_back(in__.scalar_lb_constrain(0));
            }

            vector<Eigen::Matrix<T__,Eigen::Dynamic,1> > local;
            size_t dim_local_0__ = hs;
            local.reserve(dim_local_0__);
            for (size_t k_0__ = 0; k_0__ < dim_local_0__; ++k_0__) {
                if (jacobian__)
                    local.push_back(in__.vector_lb_constrain(0,(logical_gt(hs,0) ? K : 0 ),lp__));
                else
                    local.push_back(in__.vector_lb_constrain(0,(logical_gt(hs,0) ? K : 0 )));
            }

            vector<T__> caux;
            size_t dim_caux_0__ = logical_gt(hs,0);
            caux.reserve(dim_caux_0__);
            for (size_t k_0__ = 0; k_0__ < dim_caux_0__; ++k_0__) {
                if (jacobian__)
                    caux.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    caux.push_back(in__.scalar_lb_constrain(0));
            }

            vector<Eigen::Matrix<T__,Eigen::Dynamic,1> > mix;
            size_t dim_mix_0__ = (primitive_value(logical_eq(prior_dist,5)) || primitive_value(logical_eq(prior_dist,6)));
            mix.reserve(dim_mix_0__);
            for (size_t k_0__ = 0; k_0__ < dim_mix_0__; ++k_0__) {
                if (jacobian__)
                    mix.push_back(in__.vector_lb_constrain(0,K,lp__));
                else
                    mix.push_back(in__.vector_lb_constrain(0,K));
            }

            vector<T__> ool;
            size_t dim_ool_0__ = logical_eq(prior_dist,6);
            ool.reserve(dim_ool_0__);
            for (size_t k_0__ = 0; k_0__ < dim_ool_0__; ++k_0__) {
                if (jacobian__)
                    ool.push_back(in__.scalar_lb_constrain(0,lp__));
                else
                    ool.push_back(in__.scalar_lb_constrain(0));
            }


            // transformed parameters
            current_statement_begin__ = 215;
            validate_non_negative_index("beta", "K", K);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  beta(static_cast<Eigen::VectorXd::Index>(K));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, DUMMY_VAR__);
            stan::math::fill(beta,DUMMY_VAR__);
            current_statement_begin__ = 218;
            validate_non_negative_index("exp_scale", "logical_eq(dist,1)", logical_eq(dist,1));
            vector<T__> exp_scale(logical_eq(dist,1));
            stan::math::initialize(exp_scale, DUMMY_VAR__);
            stan::math::fill(exp_scale,DUMMY_VAR__);
            current_statement_begin__ = 219;
            validate_non_negative_index("wei_shape", "logical_eq(dist,2)", logical_eq(dist,2));
            vector<T__> wei_shape(logical_eq(dist,2));
            stan::math::initialize(wei_shape, DUMMY_VAR__);
            stan::math::fill(wei_shape,DUMMY_VAR__);
            current_statement_begin__ = 220;
            validate_non_negative_index("wei_scale", "logical_eq(dist,2)", logical_eq(dist,2));
            vector<T__> wei_scale(logical_eq(dist,2));
            stan::math::initialize(wei_scale, DUMMY_VAR__);
            stan::math::fill(wei_scale,DUMMY_VAR__);
            current_statement_begin__ = 221;
            validate_non_negative_index("fpm_coefs", "df", df);
            validate_non_negative_index("fpm_coefs", "logical_eq(dist,3)", logical_eq(dist,3));
            vector<Eigen::Matrix<T__,Eigen::Dynamic,1> > fpm_coefs(logical_eq(dist,3), (Eigen::Matrix<T__,Eigen::Dynamic,1> (static_cast<Eigen::VectorXd::Index>(df))));
            stan::math::initialize(fpm_coefs, DUMMY_VAR__);
            stan::math::fill(fpm_coefs,DUMMY_VAR__);


            current_statement_begin__ = 224;
            stan::math::assign(beta, make_beta(z_beta,prior_dist,prior_mu,prior_sd,prior_df,global_prior_sd,global,local,ool,mix,rep_array(1.0,0),0,slab_sd,caux, pstream__));
            current_statement_begin__ = 230;
            if (as_bool(logical_eq(dist,1))) {

                current_statement_begin__ = 231;
                stan::math::assign(get_base1_lhs(exp_scale,1,"exp_scale",1), (get_base1(z_exp_scale,1,"z_exp_scale",1) * prior_sd_for_exp_scale));
            } else if (as_bool(logical_eq(dist,2))) {

                current_statement_begin__ = 234;
                stan::math::assign(get_base1_lhs(wei_shape,1,"wei_shape",1), (get_base1(z_wei_shape,1,"z_wei_shape",1) * prior_sd_for_wei_shape));
                current_statement_begin__ = 235;
                stan::math::assign(get_base1_lhs(wei_scale,1,"wei_scale",1), (get_base1(z_wei_scale,1,"z_wei_scale",1) * prior_sd_for_wei_scale));
            } else if (as_bool(logical_eq(dist,3))) {

                current_statement_begin__ = 238;
                stan::math::assign(get_base1_lhs(fpm_coefs,1,"fpm_coefs",1), add(prior_mu_for_fpm_coefs,elt_multiply(get_base1(z_fpm_coefs,1,"z_fpm_coefs",1),prior_sd_for_fpm_coefs)));
            }

            // validate transformed parameters
            for (int i0__ = 0; i0__ < K; ++i0__) {
                if (stan::math::is_uninitialized(beta(i0__))) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: beta" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < logical_eq(dist,1); ++i0__) {
                if (stan::math::is_uninitialized(exp_scale[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: exp_scale" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < logical_eq(dist,2); ++i0__) {
                if (stan::math::is_uninitialized(wei_shape[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: wei_shape" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < logical_eq(dist,2); ++i0__) {
                if (stan::math::is_uninitialized(wei_scale[i0__])) {
                    std::stringstream msg__;
                    msg__ << "Undefined transformed parameter: wei_scale" << '[' << i0__ << ']';
                    throw std::runtime_error(msg__.str());
                }
            }
            for (int i0__ = 0; i0__ < logical_eq(dist,3); ++i0__) {
                for (int i1__ = 0; i1__ < df; ++i1__) {
                    if (stan::math::is_uninitialized(fpm_coefs[i0__](i1__))) {
                        std::stringstream msg__;
                        msg__ << "Undefined transformed parameter: fpm_coefs" << '[' << i0__ << ']' << '[' << i1__ << ']';
                        throw std::runtime_error(msg__.str());
                    }
                }
            }

            const char* function__ = "validate transformed params";
            (void) function__;  // dummy to suppress unused var warning
            current_statement_begin__ = 215;
            current_statement_begin__ = 218;
            for (int k0__ = 0; k0__ < logical_eq(dist,1); ++k0__) {
                check_greater_or_equal(function__,"exp_scale[k0__]",exp_scale[k0__],0);
            }
            current_statement_begin__ = 219;
            for (int k0__ = 0; k0__ < logical_eq(dist,2); ++k0__) {
                check_greater_or_equal(function__,"wei_shape[k0__]",wei_shape[k0__],0);
            }
            current_statement_begin__ = 220;
            for (int k0__ = 0; k0__ < logical_eq(dist,2); ++k0__) {
                check_greater_or_equal(function__,"wei_scale[k0__]",wei_scale[k0__],0);
            }
            current_statement_begin__ = 221;

            // model body
            {
            current_statement_begin__ = 245;
            validate_non_negative_index("eta", "nrows", nrows);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  eta(static_cast<Eigen::VectorXd::Index>(nrows));
            (void) eta;  // dummy to suppress unused var warning

            stan::math::initialize(eta, DUMMY_VAR__);
            stan::math::fill(eta,DUMMY_VAR__);
            current_statement_begin__ = 246;
            validate_non_negative_index("log_basehaz", "nrows", nrows);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  log_basehaz(static_cast<Eigen::VectorXd::Index>(nrows));
            (void) log_basehaz;  // dummy to suppress unused var warning

            stan::math::initialize(log_basehaz, DUMMY_VAR__);
            stan::math::fill(log_basehaz,DUMMY_VAR__);
            current_statement_begin__ = 247;
            validate_non_negative_index("log_basesurv_beg", "nrows", nrows);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  log_basesurv_beg(static_cast<Eigen::VectorXd::Index>(nrows));
            (void) log_basesurv_beg;  // dummy to suppress unused var warning

            stan::math::initialize(log_basesurv_beg, DUMMY_VAR__);
            stan::math::fill(log_basesurv_beg,DUMMY_VAR__);
            current_statement_begin__ = 248;
            validate_non_negative_index("log_basesurv_end", "nrows", nrows);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  log_basesurv_end(static_cast<Eigen::VectorXd::Index>(nrows));
            (void) log_basesurv_end;  // dummy to suppress unused var warning

            stan::math::initialize(log_basesurv_end, DUMMY_VAR__);
            stan::math::fill(log_basesurv_end,DUMMY_VAR__);
            current_statement_begin__ = 249;
            validate_non_negative_index("log_haz", "nrows", nrows);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  log_haz(static_cast<Eigen::VectorXd::Index>(nrows));
            (void) log_haz;  // dummy to suppress unused var warning

            stan::math::initialize(log_haz, DUMMY_VAR__);
            stan::math::fill(log_haz,DUMMY_VAR__);
            current_statement_begin__ = 250;
            validate_non_negative_index("log_surv", "nrows", nrows);
            Eigen::Matrix<T__,Eigen::Dynamic,1>  log_surv(static_cast<Eigen::VectorXd::Index>(nrows));
            (void) log_surv;  // dummy to suppress unused var warning

            stan::math::initialize(log_surv, DUMMY_VAR__);
            stan::math::fill(log_surv,DUMMY_VAR__);


            current_statement_begin__ = 253;
            if (as_bool(logical_gt(K,0))) {

                current_statement_begin__ = 254;
                stan::math::assign(eta, multiply(x,beta));
            } else {

                current_statement_begin__ = 257;
                stan::math::assign(eta, rep_vector(0.0,nrows));
            }
            current_statement_begin__ = 261;
            if (as_bool(logical_eq(dist,1))) {

                current_statement_begin__ = 262;
                stan::math::assign(log_basehaz, rep_vector(log(get_base1(exp_scale,1,"exp_scale",1)),nrows));
                current_statement_begin__ = 263;
                stan::math::assign(log_basesurv_beg, multiply(-(get_base1(exp_scale,1,"exp_scale",1)),t_beg));
                current_statement_begin__ = 264;
                stan::math::assign(log_basesurv_end, multiply(-(get_base1(exp_scale,1,"exp_scale",1)),t_end));
            } else if (as_bool(logical_eq(dist,2))) {

                current_statement_begin__ = 267;
                stan::math::assign(log_basehaz, add((log(get_base1(wei_shape,1,"wei_shape",1)) + log(get_base1(wei_scale,1,"wei_scale",1))),multiply(t_end,(get_base1(wei_shape,1,"wei_shape",1) - 1))));
                current_statement_begin__ = 268;
                for (int n = 1; n <= nrows; ++n) {

                    current_statement_begin__ = 269;
                    stan::math::assign(get_base1_lhs(log_basesurv_beg,n,"log_basesurv_beg",1), (-(get_base1(wei_scale,1,"wei_scale",1)) * pow(get_base1(t_beg,n,"t_beg",1),get_base1(wei_shape,1,"wei_shape",1))));
                    current_statement_begin__ = 270;
                    stan::math::assign(get_base1_lhs(log_basesurv_end,n,"log_basesurv_end",1), (-(get_base1(wei_scale,1,"wei_scale",1)) * pow(get_base1(t_end,n,"t_end",1),get_base1(wei_shape,1,"wei_shape",1))));
                }
            } else if (as_bool(logical_eq(dist,3))) {

                current_statement_begin__ = 274;
                stan::math::assign(log_basehaz, add(add(minus(log(t_end)),log(multiply(fpm_dx_end,get_base1(fpm_coefs,1,"fpm_coefs",1)))),multiply(fpm_x_end,get_base1(fpm_coefs,1,"fpm_coefs",1))));
                current_statement_begin__ = 275;
                stan::math::assign(log_basesurv_beg, minus(exp(multiply(fpm_x_beg,get_base1(fpm_coefs,1,"fpm_coefs",1)))));
                current_statement_begin__ = 276;
                stan::math::assign(log_basesurv_end, minus(exp(multiply(fpm_x_end,get_base1(fpm_coefs,1,"fpm_coefs",1)))));
            }
            current_statement_begin__ = 280;
            stan::math::assign(log_haz, add(log_basehaz,eta));
            current_statement_begin__ = 283;
            stan::math::assign(log_surv, elt_multiply(subtract(log_basesurv_end,log_basesurv_beg),exp(eta)));
            current_statement_begin__ = 286;
            if (as_bool(logical_eq(prior_PD,0))) {

                current_statement_begin__ = 287;
                lp_accum__.add((sum(elt_multiply(d,log_haz)) + sum(log_surv)));
            }
            current_statement_begin__ = 291;
            beta_lp(z_beta,prior_dist,prior_sd,prior_df,global_prior_df,local,global,mix,ool,slab_df,caux, lp__, lp_accum__, pstream__);
            }

        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }

        lp_accum__.add(lp__);
        return lp_accum__.sum();

    } // log_prob()

    template <bool propto, bool jacobian, typename T_>
    T_ log_prob(Eigen::Matrix<T_,Eigen::Dynamic,1>& params_r,
               std::ostream* pstream = 0) const {
      std::vector<T_> vec_params_r;
      vec_params_r.reserve(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        vec_params_r.push_back(params_r(i));
      std::vector<int> vec_params_i;
      return log_prob<propto,jacobian,T_>(vec_params_r, vec_params_i, pstream);
    }


    void get_param_names(std::vector<std::string>& names__) const {
        names__.resize(0);
        names__.push_back("z_beta");
        names__.push_back("z_exp_scale");
        names__.push_back("z_wei_shape");
        names__.push_back("z_wei_scale");
        names__.push_back("z_fpm_coefs");
        names__.push_back("global");
        names__.push_back("local");
        names__.push_back("caux");
        names__.push_back("mix");
        names__.push_back("ool");
        names__.push_back("beta");
        names__.push_back("exp_scale");
        names__.push_back("wei_shape");
        names__.push_back("wei_scale");
        names__.push_back("fpm_coefs");
    }


    void get_dims(std::vector<std::vector<size_t> >& dimss__) const {
        dimss__.resize(0);
        std::vector<size_t> dims__;
        dims__.resize(0);
        dims__.push_back(K);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(logical_eq(dist,1));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(logical_eq(dist,2));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(logical_eq(dist,2));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(logical_eq(dist,3));
        dims__.push_back(df);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(hs);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(hs);
        dims__.push_back((logical_gt(hs,0) ? K : 0 ));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(logical_gt(hs,0));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back((primitive_value(logical_eq(prior_dist,5)) || primitive_value(logical_eq(prior_dist,6))));
        dims__.push_back(K);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(logical_eq(prior_dist,6));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(K);
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(logical_eq(dist,1));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(logical_eq(dist,2));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(logical_eq(dist,2));
        dimss__.push_back(dims__);
        dims__.resize(0);
        dims__.push_back(logical_eq(dist,3));
        dims__.push_back(df);
        dimss__.push_back(dims__);
    }

    template <typename RNG>
    void write_array(RNG& base_rng__,
                     std::vector<double>& params_r__,
                     std::vector<int>& params_i__,
                     std::vector<double>& vars__,
                     bool include_tparams__ = true,
                     bool include_gqs__ = true,
                     std::ostream* pstream__ = 0) const {
        vars__.resize(0);
        stan::io::reader<double> in__(params_r__,params_i__);
        static const char* function__ = "model_surv_namespace::write_array";
        (void) function__;  // dummy to suppress unused var warning
        // read-transform, write parameters
        vector_d z_beta = in__.vector_constrain(K);
        vector<double> z_exp_scale;
        size_t dim_z_exp_scale_0__ = logical_eq(dist,1);
        for (size_t k_0__ = 0; k_0__ < dim_z_exp_scale_0__; ++k_0__) {
            z_exp_scale.push_back(in__.scalar_lb_constrain(0));
        }
        vector<double> z_wei_shape;
        size_t dim_z_wei_shape_0__ = logical_eq(dist,2);
        for (size_t k_0__ = 0; k_0__ < dim_z_wei_shape_0__; ++k_0__) {
            z_wei_shape.push_back(in__.scalar_lb_constrain(0));
        }
        vector<double> z_wei_scale;
        size_t dim_z_wei_scale_0__ = logical_eq(dist,2);
        for (size_t k_0__ = 0; k_0__ < dim_z_wei_scale_0__; ++k_0__) {
            z_wei_scale.push_back(in__.scalar_lb_constrain(0));
        }
        vector<vector_d> z_fpm_coefs;
        size_t dim_z_fpm_coefs_0__ = logical_eq(dist,3);
        for (size_t k_0__ = 0; k_0__ < dim_z_fpm_coefs_0__; ++k_0__) {
            z_fpm_coefs.push_back(in__.vector_constrain(df));
        }
        vector<double> global;
        size_t dim_global_0__ = hs;
        for (size_t k_0__ = 0; k_0__ < dim_global_0__; ++k_0__) {
            global.push_back(in__.scalar_lb_constrain(0));
        }
        vector<vector_d> local;
        size_t dim_local_0__ = hs;
        for (size_t k_0__ = 0; k_0__ < dim_local_0__; ++k_0__) {
            local.push_back(in__.vector_lb_constrain(0,(logical_gt(hs,0) ? K : 0 )));
        }
        vector<double> caux;
        size_t dim_caux_0__ = logical_gt(hs,0);
        for (size_t k_0__ = 0; k_0__ < dim_caux_0__; ++k_0__) {
            caux.push_back(in__.scalar_lb_constrain(0));
        }
        vector<vector_d> mix;
        size_t dim_mix_0__ = (primitive_value(logical_eq(prior_dist,5)) || primitive_value(logical_eq(prior_dist,6)));
        for (size_t k_0__ = 0; k_0__ < dim_mix_0__; ++k_0__) {
            mix.push_back(in__.vector_lb_constrain(0,K));
        }
        vector<double> ool;
        size_t dim_ool_0__ = logical_eq(prior_dist,6);
        for (size_t k_0__ = 0; k_0__ < dim_ool_0__; ++k_0__) {
            ool.push_back(in__.scalar_lb_constrain(0));
        }
            for (int k_0__ = 0; k_0__ < K; ++k_0__) {
            vars__.push_back(z_beta[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < logical_eq(dist,1); ++k_0__) {
            vars__.push_back(z_exp_scale[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < logical_eq(dist,2); ++k_0__) {
            vars__.push_back(z_wei_shape[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < logical_eq(dist,2); ++k_0__) {
            vars__.push_back(z_wei_scale[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < df; ++k_1__) {
                for (int k_0__ = 0; k_0__ < logical_eq(dist,3); ++k_0__) {
                vars__.push_back(z_fpm_coefs[k_0__][k_1__]);
                }
            }
            for (int k_0__ = 0; k_0__ < hs; ++k_0__) {
            vars__.push_back(global[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < (logical_gt(hs,0) ? K : 0 ); ++k_1__) {
                for (int k_0__ = 0; k_0__ < hs; ++k_0__) {
                vars__.push_back(local[k_0__][k_1__]);
                }
            }
            for (int k_0__ = 0; k_0__ < logical_gt(hs,0); ++k_0__) {
            vars__.push_back(caux[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < K; ++k_1__) {
                for (int k_0__ = 0; k_0__ < (primitive_value(logical_eq(prior_dist,5)) || primitive_value(logical_eq(prior_dist,6))); ++k_0__) {
                vars__.push_back(mix[k_0__][k_1__]);
                }
            }
            for (int k_0__ = 0; k_0__ < logical_eq(prior_dist,6); ++k_0__) {
            vars__.push_back(ool[k_0__]);
            }

        if (!include_tparams__) return;
        // declare and define transformed parameters
        double lp__ = 0.0;
        (void) lp__;  // dummy to suppress unused var warning
        stan::math::accumulator<double> lp_accum__;

        double DUMMY_VAR__(std::numeric_limits<double>::quiet_NaN());
        (void) DUMMY_VAR__;  // suppress unused var warning

        try {
            current_statement_begin__ = 215;
            validate_non_negative_index("beta", "K", K);
            vector_d beta(static_cast<Eigen::VectorXd::Index>(K));
            (void) beta;  // dummy to suppress unused var warning

            stan::math::initialize(beta, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(beta,DUMMY_VAR__);
            current_statement_begin__ = 218;
            validate_non_negative_index("exp_scale", "logical_eq(dist,1)", logical_eq(dist,1));
            vector<double> exp_scale(logical_eq(dist,1), 0.0);
            stan::math::initialize(exp_scale, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(exp_scale,DUMMY_VAR__);
            current_statement_begin__ = 219;
            validate_non_negative_index("wei_shape", "logical_eq(dist,2)", logical_eq(dist,2));
            vector<double> wei_shape(logical_eq(dist,2), 0.0);
            stan::math::initialize(wei_shape, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(wei_shape,DUMMY_VAR__);
            current_statement_begin__ = 220;
            validate_non_negative_index("wei_scale", "logical_eq(dist,2)", logical_eq(dist,2));
            vector<double> wei_scale(logical_eq(dist,2), 0.0);
            stan::math::initialize(wei_scale, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(wei_scale,DUMMY_VAR__);
            current_statement_begin__ = 221;
            validate_non_negative_index("fpm_coefs", "df", df);
            validate_non_negative_index("fpm_coefs", "logical_eq(dist,3)", logical_eq(dist,3));
            vector<vector_d> fpm_coefs(logical_eq(dist,3), (vector_d(static_cast<Eigen::VectorXd::Index>(df))));
            stan::math::initialize(fpm_coefs, std::numeric_limits<double>::quiet_NaN());
            stan::math::fill(fpm_coefs,DUMMY_VAR__);


            current_statement_begin__ = 224;
            stan::math::assign(beta, make_beta(z_beta,prior_dist,prior_mu,prior_sd,prior_df,global_prior_sd,global,local,ool,mix,rep_array(1.0,0),0,slab_sd,caux, pstream__));
            current_statement_begin__ = 230;
            if (as_bool(logical_eq(dist,1))) {

                current_statement_begin__ = 231;
                stan::math::assign(get_base1_lhs(exp_scale,1,"exp_scale",1), (get_base1(z_exp_scale,1,"z_exp_scale",1) * prior_sd_for_exp_scale));
            } else if (as_bool(logical_eq(dist,2))) {

                current_statement_begin__ = 234;
                stan::math::assign(get_base1_lhs(wei_shape,1,"wei_shape",1), (get_base1(z_wei_shape,1,"z_wei_shape",1) * prior_sd_for_wei_shape));
                current_statement_begin__ = 235;
                stan::math::assign(get_base1_lhs(wei_scale,1,"wei_scale",1), (get_base1(z_wei_scale,1,"z_wei_scale",1) * prior_sd_for_wei_scale));
            } else if (as_bool(logical_eq(dist,3))) {

                current_statement_begin__ = 238;
                stan::math::assign(get_base1_lhs(fpm_coefs,1,"fpm_coefs",1), add(prior_mu_for_fpm_coefs,elt_multiply(get_base1(z_fpm_coefs,1,"z_fpm_coefs",1),prior_sd_for_fpm_coefs)));
            }

            // validate transformed parameters
            current_statement_begin__ = 215;
            current_statement_begin__ = 218;
            for (int k0__ = 0; k0__ < logical_eq(dist,1); ++k0__) {
                check_greater_or_equal(function__,"exp_scale[k0__]",exp_scale[k0__],0);
            }
            current_statement_begin__ = 219;
            for (int k0__ = 0; k0__ < logical_eq(dist,2); ++k0__) {
                check_greater_or_equal(function__,"wei_shape[k0__]",wei_shape[k0__],0);
            }
            current_statement_begin__ = 220;
            for (int k0__ = 0; k0__ < logical_eq(dist,2); ++k0__) {
                check_greater_or_equal(function__,"wei_scale[k0__]",wei_scale[k0__],0);
            }
            current_statement_begin__ = 221;

            // write transformed parameters
            for (int k_0__ = 0; k_0__ < K; ++k_0__) {
            vars__.push_back(beta[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < logical_eq(dist,1); ++k_0__) {
            vars__.push_back(exp_scale[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < logical_eq(dist,2); ++k_0__) {
            vars__.push_back(wei_shape[k_0__]);
            }
            for (int k_0__ = 0; k_0__ < logical_eq(dist,2); ++k_0__) {
            vars__.push_back(wei_scale[k_0__]);
            }
            for (int k_1__ = 0; k_1__ < df; ++k_1__) {
                for (int k_0__ = 0; k_0__ < logical_eq(dist,3); ++k_0__) {
                vars__.push_back(fpm_coefs[k_0__][k_1__]);
                }
            }

            if (!include_gqs__) return;
            // declare and define generated quantities



            // validate generated quantities

            // write generated quantities
        } catch (const std::exception& e) {
            stan::lang::rethrow_located(e, current_statement_begin__, prog_reader__());
            // Next line prevents compiler griping about no return
            throw std::runtime_error("*** IF YOU SEE THIS, PLEASE REPORT A BUG ***");
        }
    }

    template <typename RNG>
    void write_array(RNG& base_rng,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& params_r,
                     Eigen::Matrix<double,Eigen::Dynamic,1>& vars,
                     bool include_tparams = true,
                     bool include_gqs = true,
                     std::ostream* pstream = 0) const {
      std::vector<double> params_r_vec(params_r.size());
      for (int i = 0; i < params_r.size(); ++i)
        params_r_vec[i] = params_r(i);
      std::vector<double> vars_vec;
      std::vector<int> params_i_vec;
      write_array(base_rng,params_r_vec,params_i_vec,vars_vec,include_tparams,include_gqs,pstream);
      vars.resize(vars_vec.size());
      for (int i = 0; i < vars.size(); ++i)
        vars(i) = vars_vec[i];
    }

    static std::string model_name() {
        return "model_surv";
    }


    void constrained_param_names(std::vector<std::string>& param_names__,
                                 bool include_tparams__ = true,
                                 bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= K; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "z_beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= logical_eq(dist,1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "z_exp_scale" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= logical_eq(dist,2); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "z_wei_shape" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= logical_eq(dist,2); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "z_wei_scale" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= df; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= logical_eq(dist,3); ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "z_fpm_coefs" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_0__ = 1; k_0__ <= hs; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "global" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= (logical_gt(hs,0) ? K : 0 ); ++k_1__) {
            for (int k_0__ = 1; k_0__ <= hs; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "local" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_0__ = 1; k_0__ <= logical_gt(hs,0); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "caux" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= K; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= (primitive_value(logical_eq(prior_dist,5)) || primitive_value(logical_eq(prior_dist,6))); ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mix" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_0__ = 1; k_0__ <= logical_eq(prior_dist,6); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ool" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= K; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= logical_eq(dist,1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "exp_scale" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= logical_eq(dist,2); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "wei_shape" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= logical_eq(dist,2); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "wei_scale" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= df; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= logical_eq(dist,3); ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "fpm_coefs" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }

        if (!include_gqs__) return;
    }


    void unconstrained_param_names(std::vector<std::string>& param_names__,
                                   bool include_tparams__ = true,
                                   bool include_gqs__ = true) const {
        std::stringstream param_name_stream__;
        for (int k_0__ = 1; k_0__ <= K; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "z_beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= logical_eq(dist,1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "z_exp_scale" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= logical_eq(dist,2); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "z_wei_shape" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= logical_eq(dist,2); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "z_wei_scale" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= df; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= logical_eq(dist,3); ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "z_fpm_coefs" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_0__ = 1; k_0__ <= hs; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "global" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= (logical_gt(hs,0) ? K : 0 ); ++k_1__) {
            for (int k_0__ = 1; k_0__ <= hs; ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "local" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_0__ = 1; k_0__ <= logical_gt(hs,0); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "caux" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= K; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= (primitive_value(logical_eq(prior_dist,5)) || primitive_value(logical_eq(prior_dist,6))); ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "mix" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }
        for (int k_0__ = 1; k_0__ <= logical_eq(prior_dist,6); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "ool" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }

        if (!include_gqs__ && !include_tparams__) return;
        for (int k_0__ = 1; k_0__ <= K; ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "beta" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= logical_eq(dist,1); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "exp_scale" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= logical_eq(dist,2); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "wei_shape" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_0__ = 1; k_0__ <= logical_eq(dist,2); ++k_0__) {
            param_name_stream__.str(std::string());
            param_name_stream__ << "wei_scale" << '.' << k_0__;
            param_names__.push_back(param_name_stream__.str());
        }
        for (int k_1__ = 1; k_1__ <= df; ++k_1__) {
            for (int k_0__ = 1; k_0__ <= logical_eq(dist,3); ++k_0__) {
                param_name_stream__.str(std::string());
                param_name_stream__ << "fpm_coefs" << '.' << k_0__ << '.' << k_1__;
                param_names__.push_back(param_name_stream__.str());
            }
        }

        if (!include_gqs__) return;
    }

}; // model

}

typedef model_surv_namespace::model_surv stan_model;


#endif
